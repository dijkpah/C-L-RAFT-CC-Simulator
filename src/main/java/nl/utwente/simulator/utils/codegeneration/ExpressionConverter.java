package nl.utwente.simulator.utils.codegeneration;

import nl.utwente.simulator.utils.codegeneration.antlr.ExpressionBaseVisitor;
import nl.utwente.simulator.utils.codegeneration.antlr.ExpressionLexer;
import nl.utwente.simulator.utils.codegeneration.antlr.ExpressionParser;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.apache.commons.codec.CharEncoding;

/**
 * Converts a mathematical expression to a Java expression using generated ANTLR 3.0 code
 */
public class ExpressionConverter extends ExpressionBaseVisitor<String> {

    ExpressionLexer lexer;
    CommonTokenStream tokens;
    ExpressionParser parser;

    public String convert(String expression) {
        lexer = new ExpressionLexer(CharStreams.fromString(expression, CharEncoding.UTF_8));
        tokens = new CommonTokenStream(lexer);
        parser = new ExpressionParser(tokens);
        return visit(parser.expression());
    }

    @Override
    public String visitExpression(ExpressionParser.ExpressionContext ctx) {
        return visitAdditiveExpression(ctx.additiveExpression());
    }

    @Override
    public String visitAdditiveExpression(ExpressionParser.AdditiveExpressionContext ctx) {
        if (ctx.getChildCount() == 1) {
            return visit(ctx.getChild(0));
        } else if (ctx.getChildCount() == 3) {
            String leftChild = visit(ctx.getChild(0));
            String rightChild = visit(ctx.getChild(2));
            String operator = ctx.getChild(1).getText();
            return leftChild + operator + rightChild;
        } else {
            throw new RuntimeException("Incorrect number of arguments");                                                //We do not want to change autogenerated superclass
        }
    }

    @Override
    public String visitMultiplicativeExpression(ExpressionParser.MultiplicativeExpressionContext ctx) {
        if (ctx.getChildCount() == 1) {
            return visit(ctx.getChild(0));
        } else if (ctx.getChildCount() == 2) {
            String leftChild = visit(ctx.getChild(0));
            String rightChild = visit(ctx.getChild(1));
            return leftChild + "*" + rightChild;
        } else if (ctx.getChildCount() == 3) {
            String leftChild = visit(ctx.getChild(0));
            String rightChild = visit(ctx.getChild(2));
            ParseTree operator = ctx.getChild(1);

            if(((TerminalNode) operator).getSymbol().getType() == ExpressionLexer.DIVISION){
                return "((double)("+leftChild+"))/"+rightChild;
            }else {
                return leftChild + "*" + rightChild;
            }
        } else {
            throw new RuntimeException("Incorrect number of arguments");
        }
    }

    @Override
    public String visitPowerExpression(ExpressionParser.PowerExpressionContext ctx) {
        if (ctx.getChildCount() == 1) {
            return visit(ctx.getChild(0));
        } else if (ctx.getChildCount() == 3) {
            String leftChild = visit(ctx.getChild(0));
            String rightChild = visit(ctx.getChild(2));
            return "Math.pow(" + leftChild + "," + rightChild + ")";
        } else {
            throw new RuntimeException("Incorrect number of arguments");                                                //We do not want to change autogenerated superclass
        }
    }

    @Override
    public String visitUnaryExpression(ExpressionParser.UnaryExpressionContext ctx) {
        if (ctx.getChildCount() == 1) {
            return visit(ctx.getChild(0));
        } else if (ctx.getChildCount() == 2) {
            ParseTree operator = ctx.getChild(0);
            String child = visit(ctx.getChild(1));
            if (operator instanceof TerminalNode) {
                if (((TerminalNode) operator).getSymbol().getType() == ExpressionLexer.MINUS) {
                    return "-" + child;
                } else if (((TerminalNode) operator).getSymbol().getType() == ExpressionLexer.SQRT) {
                    return "Math.sqrt(" + child + ")";
                } else {
                    throw new RuntimeException("Unexpected operator before " + child + ": " + operator.getText());
                }
            } else {
                throw new RuntimeException("Expected operator before " + child);
            }
        } else {
            throw new RuntimeException("Incorrect number of arguments");
        }
    }

    @Override
    public String visitPrimaryExpression(ExpressionParser.PrimaryExpressionContext ctx) {
        if (ctx.getChildCount() == 1) {
            ParseTree node = ctx.getChild(0);
            if (node instanceof TerminalNode) {
                if (((TerminalNode) node).getSymbol().getType() == ExpressionLexer.PI) {
                    return "Math.PI";
                } else if (((TerminalNode) node).getSymbol().getType() == ExpressionLexer.NUMBER) {
                    return node.getText().replace(',', '.');                                                            //Java only allows dot as decimal separator
                } else if (((TerminalNode) node).getSymbol().getType() == ExpressionLexer.VAR) {
                    return node.getText();
                } else {
                    throw new RuntimeException("Unexpected argument " + node.getText());
                }
            } else {
                throw new RuntimeException("Unexpected value: " + node.getText());
            }
        } else if (ctx.getChildCount() == 3) {
            ParseTree lparen = ctx.getChild(0);
            ParseTree rparen = ctx.getChild(2);
            String child = visit(ctx.getChild(1));
            if(!(
                lparen instanceof TerminalNode && rparen instanceof TerminalNode &&
                ((TerminalNode) lparen).getSymbol().getType() == ExpressionLexer.LPAREN &&
                ((TerminalNode) rparen).getSymbol().getType() == ExpressionLexer.RPAREN
            )){
                throw new RuntimeException("Expected braces but got "+lparen.getText()+" and "+rparen.getText());
            }
            return "("+child+")";
        } else {
            throw new RuntimeException("Incorrect number of arguments");
        }
    }
}
